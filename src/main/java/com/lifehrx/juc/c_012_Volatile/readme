Volatile
看设计模式的单例模式代码

1.Volatile： 保证线程之间可见性
堆内存：
所有线程共享里面的内存。但每个线程有自己的工作内存。
就会存在一个问题：在一份线程里面修改的值，不能及时反应到其他线程。线程之间不可见。

2. Volatile： 禁止指令重新排序
CPU为了保证高效：
会并发的执行指令，或是对指令重新排序。细节就是汇编语言。
单例：在JVM内存里，保证只有一个类的实例。例如：系统的权限管理者。(设计模式：单例模式)
为什么由JVM保证：Class load 到内存里内存由JVM进行初始化

注意：sync代码锁越少越好。

单例模式不加Volatile也没有错, 但错出现在指令重排序。
第2课 50 min - 53min
new 对象的过程：
【1】申请a = 0内存
【2】改值 a = 0
【3】把值赋值给 a = 8
超高超高的并发时候会出现这个问题，阿里京东秒杀超高并发时候可能会出现这个问题，本来预期拿到a=8, 但是拿到结果是a=0即中间结果。
但是加了Volatile之后，禁止对这个对象的指令重新排序。


【注意1】Volatile 不能代替synchronized
 由例子：T04 和 T05
 1:15:00
count 虽然可见但是, 但count++ 3条指令，但是不能保证原子性,所以一直都不是100000









