锁升级： synchronized 内部进行的各种优化

synchronized的底层实现
JDK早期的版本 重量级 - OS（都是要找操作系统申请锁）
后来的改进
锁升级的概念：
    我就是厕所所长 （一 二）


以下为锁的升级过程
sync (Object)
【1】 markword 记录这个线程ID效率非常高 （偏向锁:你是第一个线程偏向你一点默认不会来第二个）
【2】如果偏向锁有线程争用：升级为 自旋锁 占CPU
     自旋锁效率比较高, 原因是在用户态处理加锁和解锁，没有涉及内核态
     默认自旋10次以后, 用while(true)一直等着, 如果还是得不到这把锁
     等着去上厕所, 但是敲了10次门还是没进去, 就再次升级

【3】重量级锁 : 向OS操作系统申请锁


备注1. 锁只能升级不能降级
备注2. 偏向锁：两个线程就没有偏向锁了，直接进入自旋锁
备注3. 自旋锁：执行时间短（加锁代码少执行的时间比较短）, 线程数少, 用自旋
              如：20000个线程等着自旋也不行，一个线程在执行19999个线程在自旋等着这把锁, CPU也受不了
              自旋锁只是占用CPU,但是不访问操作系统，在用户态就可以解决这个问题，不经过内核态，所以效率就高。
              自旋怎么拿到：在等的10次中如果对方在第5次释放了CPU，就拿到了。还是拿不到就升级为系统锁。
备注4. 系统锁：执行时间长, 线程数多, 用系统锁
              系统锁不占用CPU，只是把旁边竞争线程放到wait队列中排着, 什么时候CPU叫你进来的时候再运行


锁的4种状态：
无锁->偏向锁->自旋锁->系统锁
